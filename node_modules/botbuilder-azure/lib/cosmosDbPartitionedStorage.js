"use strict";
/**
 * @module botbuilder-azure
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cosmos_1 = require("@azure/cosmos");
const cosmosDbKeyEscape_1 = require("./cosmosDbKeyEscape");
const doOnce_1 = require("./doOnce");
const _doOnce = new doOnce_1.DoOnce();
/**
 * @private
 * Internal data structure for storing items in a CosmosDB Collection.
 */
class DocumentStoreItem {
    /**
     * Gets the PartitionKey path to be used for this document type.
     */
    static get partitionKeyPath() {
        return '/id';
    }
    /**
     * Gets the PartitionKey value for the document.
     */
    get partitionKey() {
        return this.id;
    }
    // We can't make the partitionKey optional AND have it auto-get this.realId, so we'll use a constructor
    constructor(storeItem) {
        for (let prop in storeItem) {
            this[prop] = storeItem[prop];
        }
    }
}
/**
 * Implements an CosmosDB based storage provider using partitioning for a bot.
 */
class CosmosDbPartitionedStorage {
    /**
     * Initializes a new instance of the <see cref="CosmosDbPartitionedStorage"/> class.
     * using the provided CosmosDB credentials, database ID, and container ID.
     *
     * @param cosmosDbStorageOptions Cosmos DB partitioned storage configuration options.
     */
    constructor(cosmosDbStorageOptions) {
        this.compatabilityModePartitionKey = false;
        if (!cosmosDbStorageOptions) {
            throw new ReferenceError('CosmosDbPartitionedStorageOptions is required.');
        }
        if (!cosmosDbStorageOptions.cosmosDbEndpoint) {
            throw new ReferenceError('cosmosDbEndpoint for CosmosDB is required.');
        }
        if (!cosmosDbStorageOptions.authKey) {
            throw new ReferenceError('authKey for CosmosDB is required.');
        }
        if (!cosmosDbStorageOptions.databaseId) {
            throw new ReferenceError('databaseId is for CosmosDB required.');
        }
        if (!cosmosDbStorageOptions.containerId) {
            throw new ReferenceError('containerId for CosmosDB is required.');
        }
        // In order to support collections previously restricted to max key length of 255, we default
        // compatabilityMode to 'true'.  No compatibilityMode is opt-in only.
        if (typeof cosmosDbStorageOptions.compatibilityMode === "undefined") {
            cosmosDbStorageOptions.compatibilityMode = true;
        }
        if (cosmosDbStorageOptions.keySuffix) {
            if (cosmosDbStorageOptions.compatibilityMode) {
                throw new ReferenceError('compatibilityMode cannot be true while using a keySuffix.');
            }
            // In order to reduce key complexity, we do not allow invalid characters in a KeySuffix
            // If the keySuffix has invalid characters, the escaped key will not match
            const suffixEscaped = cosmosDbKeyEscape_1.CosmosDbKeyEscape.escapeKey(cosmosDbStorageOptions.keySuffix);
            if (cosmosDbStorageOptions.keySuffix !== suffixEscaped) {
                throw new ReferenceError(`Cannot use invalid Row Key characters: ${cosmosDbStorageOptions.keySuffix} in keySuffix`);
            }
        }
        this.cosmosDbStorageOptions = cosmosDbStorageOptions;
    }
    read(keys) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!keys) {
                throw new ReferenceError(`Keys are required when reading.`);
            }
            else if (keys.length === 0) {
                return {};
            }
            yield this.initialize();
            const storeItems = {};
            yield Promise.all(keys.map((k) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const escapedKey = cosmosDbKeyEscape_1.CosmosDbKeyEscape.escapeKey(k, this.cosmosDbStorageOptions.keySuffix, this.cosmosDbStorageOptions.compatibilityMode);
                    const readItemResponse = yield this.container.item(escapedKey, this.getPartitionKey(escapedKey)).read();
                    const documentStoreItem = readItemResponse.resource;
                    if (documentStoreItem) {
                        storeItems[documentStoreItem.realId] = documentStoreItem.document;
                        storeItems[documentStoreItem.realId].eTag = documentStoreItem._etag;
                    }
                }
                catch (err) {
                    // When an item is not found a CosmosException is thrown, but we want to
                    // return an empty collection so in this instance we catch and do not rethrow.
                    // Throw for any other exception.
                    if (err.code === 404) { }
                    // Throw unique error for 400s
                    else if (err.code === 400) {
                        this.throwInformativeError(`Error reading from container. You might be attempting to read from a non-partitioned 
                    container or a container that does not use '/id' as the partitionKeyPath`, err);
                    }
                    else {
                        this.throwInformativeError('Error reading from container', err);
                    }
                }
            })));
            return storeItems;
        });
    }
    write(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!changes) {
                throw new ReferenceError(`Changes are required when writing.`);
            }
            else if (changes.length === 0) {
                return;
            }
            yield this.initialize();
            yield Promise.all(Object.keys(changes).map((k) => __awaiter(this, void 0, void 0, function* () {
                const changesCopy = Object.assign({}, changes[k]);
                // Remove eTag from JSON object that was copied from IStoreItem.
                // The ETag information is updated as an _etag attribute in the document metadata.
                delete changesCopy.eTag;
                const documentChange = new DocumentStoreItem({
                    id: cosmosDbKeyEscape_1.CosmosDbKeyEscape.escapeKey(k, this.cosmosDbStorageOptions.keySuffix, this.cosmosDbStorageOptions.compatibilityMode),
                    realId: k,
                    document: changesCopy
                });
                const eTag = changes[k].eTag;
                const ac = eTag !== '*' && eTag != null && eTag.length > 0 ? { accessCondition: { type: 'IfMatch', condition: eTag } } : undefined;
                try {
                    yield this.container.items
                        .upsert(documentChange, ac);
                }
                catch (err) {
                    this.throwInformativeError('Error upserting document', err);
                }
            })));
        });
    }
    delete(keys) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initialize();
            yield Promise.all(keys.map((k) => __awaiter(this, void 0, void 0, function* () {
                const escapedKey = cosmosDbKeyEscape_1.CosmosDbKeyEscape.escapeKey(k, this.cosmosDbStorageOptions.keySuffix, this.cosmosDbStorageOptions.compatibilityMode);
                try {
                    yield this.container
                        .item(escapedKey, this.getPartitionKey(escapedKey))
                        .delete();
                }
                catch (err) {
                    // If trying to delete a document that doesn't exist, do nothing. Otherwise, throw
                    if (err.code === 404) { }
                    else {
                        this.throwInformativeError('Unable to delete document', err);
                    }
                }
            })));
        });
    }
    /**
     * Connects to the CosmosDB database and creates / gets the container.
     */
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.container) {
                if (!this.client) {
                    this.client = new cosmos_1.CosmosClient(Object.assign({ endpoint: this.cosmosDbStorageOptions.cosmosDbEndpoint, key: this.cosmosDbStorageOptions.authKey }, this.cosmosDbStorageOptions.cosmosClientOptions));
                }
                this.container = yield _doOnce.waitFor(() => __awaiter(this, void 0, void 0, function* () { return yield this.getOrCreateContainer(); }));
            }
        });
    }
    getOrCreateContainer() {
        return __awaiter(this, void 0, void 0, function* () {
            let createIfNotExists = !this.cosmosDbStorageOptions.compatibilityMode;
            let container;
            if (this.cosmosDbStorageOptions.compatibilityMode) {
                try {
                    container = yield this.client
                        .database(this.cosmosDbStorageOptions.databaseId)
                        .container(this.cosmosDbStorageOptions.containerId);
                    const partitionKeyPath = yield container.readPartitionKeyDefinition();
                    const paths = partitionKeyPath.resource.paths;
                    if (paths) {
                        // Containers created with CosmosDbStorage had no partition key set, so the default was '/_partitionKey'.
                        if (paths.indexOf('/_partitionKey') !== -1) {
                            this.compatabilityModePartitionKey = true;
                        }
                        else if (paths.indexOf(DocumentStoreItem.partitionKeyPath) === -1) {
                            // We are not supporting custom Partition Key Paths.
                            new Error(`Custom Partition Key Paths are not supported. ${this.cosmosDbStorageOptions.containerId} has a custom Partition Key Path of ${paths[0]}.`);
                        }
                    }
                    else {
                        this.compatabilityModePartitionKey = true;
                    }
                    return container;
                }
                catch (err) {
                    createIfNotExists = true;
                }
            }
            if (createIfNotExists) {
                const result = yield this.client
                    .database(this.cosmosDbStorageOptions.databaseId)
                    .containers.createIfNotExists({
                    id: this.cosmosDbStorageOptions.containerId,
                    partitionKey: {
                        paths: [DocumentStoreItem.partitionKeyPath]
                    },
                    throughput: this.cosmosDbStorageOptions.containerThroughput
                });
                return result.container;
            }
        });
    }
    getPartitionKey(key) {
        return this.compatabilityModePartitionKey ? undefined : key;
    }
    /**
     * The Cosmos JS SDK doesn't return very descriptive errors and not all errors contain a body.
     * This provides more detailed errors and err['message'] prevents ReferenceError
     */
    throwInformativeError(prependedMessage, err) {
        if (typeof err === 'string') {
            err = new Error(err);
        }
        err['message'] = `[${prependedMessage}] ${err['message']}`;
        throw err;
    }
}
exports.CosmosDbPartitionedStorage = CosmosDbPartitionedStorage;
//# sourceMappingURL=cosmosDbPartitionedStorage.js.map