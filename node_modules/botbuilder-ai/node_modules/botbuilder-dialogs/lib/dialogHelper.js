"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const botbuilder_core_1 = require("botbuilder-core");
const dialog_1 = require("./dialog");
const dialogEvents_1 = require("./dialogEvents");
const dialogSet_1 = require("./dialogSet");
const skillsHelpers_1 = require("./prompts/skillsHelpers");
function runDialog(dialog, context, accessor) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!dialog) {
            throw new Error('runDialog(): missing dialog');
        }
        if (!context) {
            throw new Error('runDialog(): missing context');
        }
        if (!context.activity) {
            throw new Error('runDialog(): missing context.activity');
        }
        if (!accessor) {
            throw new Error('runDialog(): missing accessor');
        }
        const dialogSet = new dialogSet_1.DialogSet(accessor);
        dialogSet.telemetryClient = dialog.telemetryClient;
        dialogSet.add(dialog);
        const dialogContext = yield dialogSet.createContext(context);
        const telemetryEventName = `runDialog(${dialog.constructor.name})`;
        const identity = context.turnState.get(context.adapter.BotIdentityKey);
        if (identity && skillsHelpers_1.isSkillClaim(identity.claims)) {
            // The bot is running as a skill.
            if (context.activity.type === botbuilder_core_1.ActivityTypes.EndOfConversation && dialogContext.stack.length > 0 && isEocComingFromParent(context)) {
                // Handle remote cancellation request if we have something in the stack.
                const activeDialogContext = getActiveDialogContext(dialogContext);
                const remoteCancelText = 'Skill was canceled through an EndOfConversation activity from the parent.';
                yield context.sendTraceActivity(telemetryEventName, undefined, undefined, `${remoteCancelText}`);
                // Send cancellation message to the top dialog in the stack to ensure all the parents are canceled in the right order. 
                yield activeDialogContext.cancelAllDialogs(true);
            }
            else {
                // Process a reprompt event sent from the parent.
                if (context.activity.type === botbuilder_core_1.ActivityTypes.Event && context.activity.name === dialogEvents_1.DialogEvents.repromptDialog && dialogContext.stack.length > 0) {
                    yield dialogContext.repromptDialog();
                    return;
                }
                // Run the Dialog with the new message Activity and capture the results so we can send end of conversation if needed.
                let result = yield dialogContext.continueDialog();
                if (result.status === dialog_1.DialogTurnStatus.empty) {
                    const startMessageText = `Starting ${dialog.id}.`;
                    yield context.sendTraceActivity(telemetryEventName, undefined, undefined, `${startMessageText}`);
                    result = yield dialogContext.beginDialog(dialog.id, null);
                }
                // Send end of conversation if it is completed or cancelled.
                if (result.status === dialog_1.DialogTurnStatus.complete || result.status === dialog_1.DialogTurnStatus.cancelled) {
                    const endMessageText = `Dialog ${dialog.id} has **completed**. Sending EndOfConversation.`;
                    yield context.sendTraceActivity(telemetryEventName, result.result, undefined, `${endMessageText}`);
                    // Send End of conversation at the end.
                    const activity = { type: botbuilder_core_1.ActivityTypes.EndOfConversation, value: result.result };
                    yield context.sendActivity(activity);
                }
            }
        }
        else {
            // The bot is running as a standard bot.
            const results = yield dialogContext.continueDialog();
            if (results.status === dialog_1.DialogTurnStatus.empty) {
                yield dialogContext.beginDialog(dialog.id);
            }
        }
    });
}
exports.runDialog = runDialog;
// Recursively walk up the DC stack to find the active DC.
function getActiveDialogContext(dialogContext) {
    const child = dialogContext.child;
    if (!child) {
        return dialogContext;
    }
    return getActiveDialogContext(child);
}
// We should only cancel the current dialog stack if the EoC activity is coming from a parent (a root bot or another skill).
// When the EoC is coming back from a child, we should just process that EoC normally through the 
// dialog stack and let the child dialogs handle that.
function isEocComingFromParent(context) {
    // To determine the direction we check callerId property which is set to the parent bot
    // by the BotFrameworkHttpClient on outgoing requests.
    return !!context.activity.callerId;
}
//# sourceMappingURL=dialogHelper.js.map