"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const botbuilder_core_1 = require("botbuilder-core");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const rankerTypes_1 = require("./qnamaker-interfaces/rankerTypes");
const _1 = require("./");
const qnaCardBuilder_1 = require("./qnaCardBuilder");
/**
 * Query QnAMaker knowledgebase using user utterance. The dialog will also present user with appropriate multi-turn prompt or active learning options.
 */
class QnAMakerDialog extends botbuilder_dialogs_1.WaterfallDialog {
    /**
     * Creates a new QnAMakerDialog instance.
     * @param knowledgeBaseId The Id of the QnAMaker knowledgebase to be queried.
     * @param endpointKey The endpoint key to use when querying the knowledgebase.
     * @param hostName Hostname to be used to form the QnAMaker host URL, which follows the following format https://{hostName}.azurewebsites.net/qnamaker
     * @param noAnswer (Optional) Activity to be sent in the event no answer is found within the knowledgebase.
     * @param threshold (Optional) The threshold above which to treat answers found from the knowledgebase as a match.
     * @param activeLearningCardTitle (Optional) Title of the card displayed showing active learning options if active learning is enabled.
     * @param cardNoMatchText (Optional) Text to be show on a button alongside active learning options, allowing a user to indicate none of the options are applicable.
     * @param top (Optional) Maximum number of answers to return from the knowledgebase.
     * @param cardNoMatchResponse (Optional) Activity to be sent if the user selects the no match option on an active learning card.
     * @param strictFilters (Optional) QnAMakerMetadata collection used to filter / boost queries to the knowledgebase.
     * @param dialogId (Optional) Id of the created dialog. Default is 'QnAMakerDialog'.
     */
    constructor(knowledgeBaseId, endpointKey, hostName, noAnswer, threshold = 0.3, activeLearningCardTitle = 'Did you mean:', cardNoMatchText = 'None of the above.', top = 3, cardNoMatchResponse, strictFilters, dialogId = 'QnAMakerDialog') {
        super(dialogId);
        // state and step value key constants
        this.qnAContextData = 'previousContextData';
        this.previousQnAId = 'previousQnAId';
        this.options = 'options';
        this.qnAData = 'qnaData';
        this.currentQuery = 'currentQuery';
        // Dialog options parameters
        this.defaultCardNoMatchResponse = `Thanks for the feedback.`;
        this.defaultNoAnswer = `No QnAMaker answers found.`;
        this.maximumScoreForLowScoreVariation = 0.95;
        this.knowledgeBaseId = knowledgeBaseId;
        this.hostName = hostName;
        this.endpointKey = endpointKey;
        this.threshold = threshold;
        this.top = top;
        this.activeLearningCardTitle = activeLearningCardTitle;
        this.cardNoMatchText = cardNoMatchText;
        this.strintFilters = strictFilters;
        this.noAnswer = noAnswer;
        this.cardNoMatchResponse = cardNoMatchResponse;
        this.addStep(this.callGenerateAnswer.bind(this));
        this.addStep(this.callTrain.bind(this));
        this.addStep(this.checkForMultiTurnPrompt.bind(this));
        this.addStep(this.displayQnAResult.bind(this));
    }
    beginDialog(dc, options) {
        const _super = Object.create(null, {
            beginDialog: { get: () => super.beginDialog }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!dc) {
                throw new Error('Missing DialogContext');
            }
            if (dc.context.activity.type != botbuilder_core_1.ActivityTypes.Message) {
                return dc.endDialog();
            }
            const dialogOptions = {
                qnaDialogResponseOptions: yield this.getQnAResponseOptions(),
                qnaMakerOptions: yield this.getQnAMakerOptions()
            };
            if (options) {
                Object.assign(dialogOptions, options);
            }
            return yield _super.beginDialog.call(this, dc, dialogOptions);
        });
    }
    /**
     * Returns a new instance of QnAMakerOptions.
    **/
    getQnAMakerOptions() {
        return {
            scoreThreshold: this.threshold,
            strictFilters: this.strintFilters,
            top: this.top,
            qnaId: 0,
            rankerType: rankerTypes_1.RankerTypes.default,
            isTest: false
        };
    }
    ;
    /**
     * Returns a new instance of QnAMakerResponseOptions.
    **/
    getQnAResponseOptions() {
        return {
            activeLearningCardTitle: this.activeLearningCardTitle,
            cardNoMatchResponse: this.cardNoMatchResponse,
            cardNoMatchText: this.cardNoMatchText,
            noAnswer: this.noAnswer
        };
    }
    /**
     * Queries the knowledgebase and either passes result to the next step or constructs and displays an active learning card
     * if active learning is enabled and multiple score close answers are returned.
    **/
    callGenerateAnswer(step) {
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            dialogOptions.qnaMakerOptions.qnaId = 0;
            dialogOptions.qnaMakerOptions.context = { previousQnAId: 0, previousUserQuery: '' };
            step.values[this.currentQuery] = step.context.activity.text;
            const previousContextData = step.activeDialog.state[this.qnAContextData] || {};
            var previousQnAId = step.activeDialog.state[this.previousQnAId] || 0;
            if (previousQnAId > 0) {
                dialogOptions.qnaMakerOptions.context = { previousQnAId: previousQnAId, previousUserQuery: '' };
                if (previousContextData[step.context.activity.text]) {
                    dialogOptions.qnaMakerOptions.qnaId = previousContextData[step.context.activity.text];
                }
            }
            const qna = this.getQnAClient();
            const response = yield qna.getAnswersRaw(step.context, dialogOptions.qnaMakerOptions);
            const qnaResponse = {
                activeLearningEnabled: response.activeLearningEnabled,
                answers: response.answers
            };
            previousQnAId = -1;
            step.activeDialog.state[this.previousQnAId] = previousQnAId;
            const isActiveLearningEnabled = qnaResponse.activeLearningEnabled;
            step.values[this.qnAData] = response.answers;
            if (isActiveLearningEnabled && qnaResponse.answers.length > 0 && qnaResponse.answers[0].score <= this.maximumScoreForLowScoreVariation) {
                qnaResponse.answers = qna.getLowScoreVariation(qnaResponse.answers);
                if (qnaResponse.answers && qnaResponse.answers.length > 1) {
                    var suggestedQuestions = [];
                    qnaResponse.answers.forEach(answer => {
                        suggestedQuestions.push(answer.questions[0]);
                    });
                    var message = qnaCardBuilder_1.QnACardBuilder.getSuggestionsCard(suggestedQuestions, dialogOptions.qnaDialogResponseOptions.activeLearningCardTitle, dialogOptions.qnaDialogResponseOptions.cardNoMatchText);
                    yield step.context.sendActivity(message);
                    step.activeDialog.state[this.options] = dialogOptions;
                    return botbuilder_dialogs_1.Dialog.EndOfTurn;
                }
            }
            const result = [];
            if (response.answers && response.answers.length > 0) {
                result.push(response.answers[0]);
            }
            step.values[this.qnAData] = result;
            step.activeDialog.state[this.options] = dialogOptions;
            return yield step.next(result);
        });
    }
    /**
     * If active learning options were displayed in the previous step and the user has selected an option other
     * than 'no match' then the training API is called, passing the user's chosen question back to the knowledgebase.
     * If no active learning options were displayed in the previous step, the incoming result is immediately passed to the next step.
    **/
    callTrain(step) {
        const _super = Object.create(null, {
            runStep: { get: () => super.runStep }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const trainResponses = step.values[this.qnAData];
            const currentQuery = step.values[this.currentQuery];
            const reply = step.context.activity.text;
            if (trainResponses && trainResponses.length > 1) {
                const qnaResult = trainResponses.filter(r => r.questions[0] == reply);
                if (qnaResult && qnaResult.length > 0) {
                    var results = [];
                    results.push(qnaResult[0]);
                    step.values[this.qnAData] = results;
                    var records = [];
                    records.push({
                        userId: step.context.activity.id,
                        userQuestion: currentQuery,
                        qnaId: qnaResult[0].id.toString()
                    });
                    var feedbackRecords = { feedbackRecords: records };
                    yield this.getQnAClient().callTrainAsync(feedbackRecords);
                    return yield step.next(qnaResult);
                }
                else if (reply == dialogOptions.qnaDialogResponseOptions.cardNoMatchText) {
                    const activity = dialogOptions.qnaDialogResponseOptions.cardNoMatchResponse;
                    yield step.context.sendActivity(activity || this.defaultCardNoMatchResponse);
                    return step.endDialog();
                }
                else {
                    return yield _super.runStep.call(this, step, 0, botbuilder_dialogs_1.DialogReason.beginCalled);
                }
            }
            return yield step.next(step.result);
        });
    }
    /**
     * If multi turn prompts are included with the answer returned from the knowledgebase, this step constructs
     * and sends an activity with a hero card displaying the answer and the multi turn prompt options.
     * If no multi turn prompts exist then the result incoming result is passed to the next step.
    **/
    checkForMultiTurnPrompt(step) {
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const response = step.result;
            if (response && response.length > 0) {
                const answer = response[0];
                if (answer.context && answer.context.prompts.length > 0) {
                    var previousContextData = {};
                    answer.context.prompts.forEach(prompt => {
                        previousContextData[prompt.displayText] = prompt.qnaId;
                    });
                    step.activeDialog.state[this.qnAContextData] = previousContextData;
                    step.activeDialog.state[this.previousQnAId] = answer.id;
                    step.activeDialog.state[this.options] = dialogOptions;
                    var message = qnaCardBuilder_1.QnACardBuilder.getQnAPromptsCard(answer);
                    yield step.context.sendActivity(message);
                    return botbuilder_dialogs_1.Dialog.EndOfTurn;
                }
            }
            return step.next(step.result);
        });
    }
    /**
     * Displays an appropriate response based on the incoming result to the user.If an answer has been identified it
     * is sent to the user. Alternatively, if no answer has been identified or the user has indicated 'no match' on an
     * active learning card, then an appropriate message is sent to the user.
    **/
    displayQnAResult(step) {
        const _super = Object.create(null, {
            runStep: { get: () => super.runStep }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const reply = step.context.activity.text;
            if (reply == dialogOptions.qnaDialogResponseOptions.cardNoMatchText) {
                const activity = dialogOptions.qnaDialogResponseOptions.cardNoMatchResponse;
                yield step.context.sendActivity(activity || this.defaultCardNoMatchResponse);
                return step.endDialog();
            }
            const previousQnaId = step.activeDialog.state[this.previousQnAId];
            if (previousQnaId > 0) {
                return yield _super.runStep.call(this, step, 0, botbuilder_dialogs_1.DialogReason.beginCalled);
            }
            const response = step.result;
            if (response && response.length > 0) {
                yield step.context.sendActivity(response[0].answer);
            }
            else {
                const activity = dialogOptions.qnaDialogResponseOptions.noAnswer;
                yield step.context.sendActivity(activity || this.defaultNoAnswer);
            }
            return yield step.endDialog(step.result);
        });
    }
    /**
     * Creates and returns an instance of the QnAMaker class used to query the knowledgebase.
    **/
    getQnAClient() {
        const endpoint = {
            knowledgeBaseId: this.knowledgeBaseId,
            endpointKey: this.endpointKey,
            host: `https://${this.hostName}.azurewebsites.net/qnamaker`
        };
        return new _1.QnAMaker(endpoint);
    }
}
exports.QnAMakerDialog = QnAMakerDialog;
//# sourceMappingURL=qnaMakerDialog.js.map