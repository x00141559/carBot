"use strict";
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const botbuilder_core_1 = require("botbuilder-core");
const dialog_1 = require("./dialog");
const dialogEvents_1 = require("./dialogEvents");
class SkillDialog extends dialog_1.Dialog {
    /**
     * A sample dialog that can wrap remote calls to a skill.
     *
     * @remarks
     * The options parameter in `beginDialog()` must be a `SkillDialogArgs` object with the initial parameters
     * for the dialog.
     *
     * @param dialogOptions
     * @param dialogId
     */
    constructor(dialogOptions, dialogId) {
        super(dialogId);
        // This key uses a simple namespace as Symbols are not serializable.
        this.DeliveryModeStateKey = 'SkillDialog.deliveryMode';
        if (!dialogOptions) {
            throw new TypeError('Missing dialogOptions parameter');
        }
        this.dialogOptions = dialogOptions;
    }
    beginDialog(dc, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const dialogArgs = SkillDialog.validateBeginDialogArgs(options);
            yield dc.context.sendTraceActivity(`${this.id}.beginDialog()`, undefined, undefined, `Using activity of type: ${dialogArgs.activity.type}`);
            // Create deep clone of the original activity to avoid altering it before forwarding it.
            const clonedActivity = this.cloneActivity(dialogArgs.activity);
            // Apply conversation reference and common properties from incoming activity before sending.
            const skillActivity = botbuilder_core_1.TurnContext.applyConversationReference(clonedActivity, botbuilder_core_1.TurnContext.getConversationReference(dc.context.activity), true);
            // Store the deliveryMode of the first forwarded activity
            dc.activeDialog.state[this.DeliveryModeStateKey] = dialogArgs.activity.deliveryMode;
            // Send the activity to the skill.
            const eocActivity = yield this.sendToSkill(dc.context, skillActivity);
            if (eocActivity) {
                return yield dc.endDialog(eocActivity.value);
            }
            return dialog_1.Dialog.EndOfTurn;
        });
    }
    continueDialog(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            yield dc.context.sendTraceActivity(`${this.id}.continueDialog()`, undefined, undefined, `ActivityType: ${dc.context.activity.type}`);
            // Handle EndOfConversation from the skill (this will be sent to the this dialog by the SkillHandler if received from the Skill)
            if (dc.context.activity.type === botbuilder_core_1.ActivityTypes.EndOfConversation) {
                yield dc.context.sendTraceActivity(`${this.id}.continueDialog()`, undefined, undefined, `Got ${botbuilder_core_1.ActivityTypes.EndOfConversation}`);
                return yield dc.endDialog(dc.context.activity.value);
            }
            // Forward only Message and Event activities to the skill
            if (dc.context.activity.type === botbuilder_core_1.ActivityTypes.Message || dc.context.activity.type === botbuilder_core_1.ActivityTypes.Event) {
                // Create deep clone of the original activity to avoid altering it before forwarding it.
                const skillActivity = this.cloneActivity(dc.context.activity);
                skillActivity.deliveryMode = dc.activeDialog.state[this.DeliveryModeStateKey];
                // Just forward to the remote skill
                const eocActivity = yield this.sendToSkill(dc.context, skillActivity);
                if (eocActivity) {
                    return yield dc.endDialog(eocActivity.value);
                }
            }
            return dialog_1.Dialog.EndOfTurn;
        });
    }
    endDialog(context, instance, reason) {
        const _super = Object.create(null, {
            endDialog: { get: () => super.endDialog }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // Send of of conversation to the skill if the dialog has been cancelled. 
            if (reason == dialog_1.DialogReason.cancelCalled || reason == dialog_1.DialogReason.replaceCalled) {
                yield context.sendTraceActivity(`${this.id}.EndDialogAsync()`, undefined, undefined, `ActivityType: ${context.activity.type}`);
                const reference = botbuilder_core_1.TurnContext.getConversationReference(context.activity);
                // Apply conversation reference and common properties from incoming activity before sending.
                const activity = botbuilder_core_1.TurnContext.applyConversationReference({ type: botbuilder_core_1.ActivityTypes.EndOfConversation }, reference, true);
                activity.channelData = context.activity.channelData;
                yield this.sendToSkill(context, activity);
            }
            yield _super.endDialog.call(this, context, instance, reason);
        });
    }
    repromptDialog(context, instance) {
        return __awaiter(this, void 0, void 0, function* () {
            // Create and send an envent to the skill so it can resume the dialog.
            const repromptEvent = { type: botbuilder_core_1.ActivityTypes.Event, name: dialogEvents_1.DialogEvents.repromptDialog };
            const reference = botbuilder_core_1.TurnContext.getConversationReference(context.activity);
            // Apply conversation reference and common properties from incoming activity before sending.
            const activity = botbuilder_core_1.TurnContext.applyConversationReference(repromptEvent, reference, true);
            yield this.sendToSkill(context, activity);
        });
    }
    resumeDialog(dc, reason, result) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.repromptDialog(dc.context, dc.activeDialog);
            return dialog_1.Dialog.EndOfTurn;
        });
    }
    /**
     * Clones the Activity entity.
     * @param activity Activity to clone.
     */
    cloneActivity(activity) {
        return Object.assign({}, activity);
    }
    static validateBeginDialogArgs(options) {
        if (!options) {
            throw new TypeError('Missing options parameter');
        }
        const dialogArgs = options;
        if (!dialogArgs.activity) {
            throw new TypeError(`"activity" is undefined or null in options.`);
        }
        // Only accept Message or Event activities
        if (dialogArgs.activity.type !== botbuilder_core_1.ActivityTypes.Message && dialogArgs.activity.type !== botbuilder_core_1.ActivityTypes.Event) {
            // Just forward to the remote skill
            throw new TypeError(`Only "${botbuilder_core_1.ActivityTypes.Message}" and "${botbuilder_core_1.ActivityTypes.Event}" activities are supported. Received activity of type "${dialogArgs.activity.type}" in options.`);
        }
        return dialogArgs;
    }
    sendToSkill(context, activity) {
        return __awaiter(this, void 0, void 0, function* () {
            // Create a conversationId to interact with the skill and send the activity
            const conversationIdFactoryOptions = {
                fromBotOAuthScope: context.turnState.get(context.adapter.OAuthScopeKey),
                fromBotId: this.dialogOptions.botId,
                activity: activity,
                botFrameworkSkill: this.dialogOptions.skill
            };
            // Create a conversationId to interact with the skill and send the activity
            let skillConversationId;
            try {
                skillConversationId = yield this.dialogOptions.conversationIdFactory.createSkillConversationIdWithOptions(conversationIdFactoryOptions);
            }
            catch (err) {
                if (err.message !== 'Not Implemented')
                    throw err;
                // If the SkillConversationIdFactoryBase implementation doesn't support createSkillConversationIdWithOptions(),
                // use createSkillConversationId() instead.
                skillConversationId = yield this.dialogOptions.conversationIdFactory.createSkillConversationId(botbuilder_core_1.TurnContext.getConversationReference(activity));
            }
            // Always save state before forwarding
            // (the dialog stack won't get updated with the skillDialog and things won't work if you don't)
            const skillInfo = this.dialogOptions.skill;
            yield this.dialogOptions.conversationState.saveChanges(context, true);
            const response = yield this.dialogOptions.skillClient.postActivity(this.dialogOptions.botId, skillInfo.appId, skillInfo.skillEndpoint, this.dialogOptions.skillHostEndpoint, skillConversationId, activity);
            // Inspect the skill response status
            if (!(response.status >= 200 && response.status <= 299)) {
                throw new Error(`Error invoking the skill id: "${skillInfo.id}" at "${skillInfo.skillEndpoint}" (status is ${response.status}). \r\n ${response.body}`);
            }
            let eocActivity;
            if (activity.deliveryMode == botbuilder_core_1.DeliveryModes.ExpectReplies && response.body && response.body.activities) {
                // Process replies in the response.Body.
                if (Array.isArray(response.body.activities)) {
                    response.body.activities.forEach((fromSkillActivity) => __awaiter(this, void 0, void 0, function* () {
                        if (fromSkillActivity.type === botbuilder_core_1.ActivityTypes.EndOfConversation) {
                            // Capture the EndOfConversation activity if it was sent from skill
                            eocActivity = fromSkillActivity;
                        }
                        else {
                            yield context.sendActivity(fromSkillActivity);
                        }
                    }));
                }
            }
            return eocActivity;
        });
    }
}
exports.SkillDialog = SkillDialog;
//# sourceMappingURL=skillDialog.js.map